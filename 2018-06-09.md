In continuing to log this journal, I've decided to add some sub-sections to denote what articles I've read and then any coding I've done.

### Articles
- [Living in a Docker world](https://www.theverge.com/circuitbreaker/2018/5/25/17386716/docker-kubernetes-containers-explained)
  - Good introduction to Docker. Not much in detail about how to exactly use it. Nice that it mentioned Kubernetes, as I wasn't as familiar with that yet.
- [How to think like a programmer — lessons in problem solving](https://medium.freecodecamp.org/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2)
  - "Problem solving is a meta-skil"
  - Having a system in place will assist with solving any problem (big or small)
  - Practice using system (article defines it as framework)
  - "...ability to break down large, complex problems is just as valuable (if not more so) than the baseline technical skills required for a job."
  - Article defines steps as:
    - 1. Understand the problem. "Write it down or create a small drawing. Tell someone about it. Use a rubber duck" I did not know about the rubber duck idea; pretty nice for introverts! "If you can't explain something in simple terms, you don't understand it." — Richard Feynman
    - 2. Plan a solution to the problem. Analyze the issue and develop an attack that you understand and can replicate later. Comments can help assist with planning.
    - 3. Divide up the work load. DO NOT ATTEMPT TO SOLVE IT ALL UP-FRONT. Breaking up into sub-problems makes things more managable for you. Solving each sub-problem eventually unlocks the overall solution to the original problem. "This technique is a cornerstone of problem-solving."
    - 4. Stuck on the problem? Find ways to deal with being stuck (take a deep breath, stop and evaluate where you are in the solution attempt.) Investigate the error or issues that are caused by your attempt. Debug through logic step-by-step to understand what is occuring. Review your solution from another perspective. Is there something that can be done to abstract this? "Sometimes we get so lost in the details of a problem that we overlook general principles that would solve the problem at a more general level." Sometimes, you just need to start again. Research using search engines or Stack Overflow. Others have problem encountered this issue before. Their solution might be quicker than brute forcing your own. Only look for solutions to sub-problems, not the overall problem.
    - 5. Practice solutions for problems. The more you solve, the better tuned your approach is to any problem. "Practice. Practice. Practice." You will recognize issues much faster and have solutions for them at the ready. Use other methods than programming such as Chess, math, Sudoku, etc.. Code challenges are another great tool if you want to continue using programming.
- [How to pick up a new technology in minimal time](https://dev.to/janux_de/how-to-pick-up-a-new-technology-in-minimal-time-2i4l)
  - The software industry moves at a really fast pace. It can be difficult to keep up with new things. We don't always have time to sit down for a dedicated course on a topic. The article presents some ideas for learning new concepts. The idea of Progressive advancement is central to these steps. Advance to the next competency level only when you are comfortable with the current.
    - Novice
        - Understand what this new thing is. Where did it come from? Whom created it? How does it solve what you need as a developer? Evaluate the developer ecosystem for it. Is it highly used in the community. Check its Github repo for stars, issues, PR counts, etc. How does it compare to similiar approaches. What can you learn in this stage that isn't going to put too much burden on you while learning. Setup the environment for comfortable development. Even just getting the "Hello World" example is a great start.
    - Beginner
      - Here you can learn the syntax, basics of what makes this language or concept work. Start investing in things like books, courses or videos. Start working on a sandbox project to connect tutorial code together in a more cohesive project. Even the obvious TODO app is a great start!
    - Intermediary
      - This stage is going to involve more effort as you have now started making apps/projects in this new language/concept. Take a sandbox idea from the previous stage and experiment with new ideas or more components to make it more refined or applicable to a larger context. Document your progress in this stage as much of the steps and/or configuration will be useful for other experiments in the future. Continue to read more about new technology. More advanced topics might be suggested through this and make good springboards for more experiments and/or learning.
    - Advanced
      - Teach others through communication. This can be done through staff members at work or writing articles online. Additional methods include screencasts, podcasts or discussion threads. Attend conferences and discuss findings and what pros or cons of tech exist. Inevitably, a new technology will spring from reaching out and discussing with others. It is at this point you can decide whether you want to start the process over again.
- [Killing Procrastination – Part 0](https://dev.to/0xcrypto/killing-procrastination--part-0-18ph)
  - Some good observations on how someone can procrastinate on their work. Only presented data and not much in solutions. I'm hoping that due to the title of this being a "Part 0" the author will present more articles on how they have overcome these issues.

### Videos
- [What’s New in Safari and WebKit](https://developer.apple.com/videos/play/wwdc2018/234/)
  - Session reviewing what is coming to Safari 12. Some interesting new items, albeit mostly Apple-centric updates. Like that they are integrating with W3C Payment Request API!


### Code Practice
I'd like to try that example from the "How to think like a programmer - lessons in problem solving" article I read earlier. The prompt was: "Write a program that reads ten numbers and figures out which number is the third highest." Basically the example comes from the idea of breaking down things into smaller tasks. I plan on trying it later today. 

During my break walking outside, I realized that this code example is actually not that difficult. I think this was due to me taking some time away from my laptop and getting some fresh air and fresh perspective.

Upon starting the exercise, I pulled from my realization that I needed to use an array to hold the series of numbers for comparison. Once I had the array in place, I knew then I could use the sort method to sort them based on their value. By default, sort treats each value as a string so I found that the first result was not my expected as the value 15 came before 2 in my log output. Then I researched on MDN how to apply a sort comparison function inside arr.sort() to treat each comparison properly. The example provided uses "a" and "b" as the comparison inputs and calls for "b" to be subtracted from the "a" input. This allowed the numbers to be sorted in ascending order. I then realized that the prompt called from them to be sorted in highest order first. My first thought was to use the arr.reverse() method to switch the values. I admit that I was ok with this until I double-checked the documentation on the comparison method I used and realized that I could simply change the subtraction rules to obtain the reverse order in sorting. This realization helped reduce the amount of code required to obtain the desired result.

This exercise was good for me in breaking down the steps required to obtain the required result. In each small step I built a strong foundation for further updates to be built on top of. Even things like realizing the sorting rule could be reversed after using the .reverse() call was a good experience as it made me realize I should think more about what the rule was actually doing, rather than just copying verbatim.

I am very happy with the result of this exercise and it supports very well what I read earlier in the "How to think like a programmer - lessons in problem solving" article.